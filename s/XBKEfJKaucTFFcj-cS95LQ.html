<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="applicable-device" content="pc,mobile">
  <meta name="keywords" content="WebSSH,Django,WebSSH,Jumpserver,运维,运维博客,运维开发,自动化,云计算,ops,sre,linux,devops,cloud" />
  <meta name="description" content="堡垒机的核心武器：WebSSH录像实现" />
  <link rel="stylesheet" href="/css/style.min.css" media="screen" type="text/css" />
  <link rel="shortcut icon" href="https://blz.nosdn.127.net/sre/images/favicon.ico" />

  <!-- Begin SEO tag -->
  <title>堡垒机的核心武器：WebSSH录像实现</title>
  <meta property="og:locale" content="zh_CN" />
  <meta property="og:site_name" content="运维咖啡吧" />
  <meta property="og:url" content="https://ops-coffee.cn/" />
  <meta property="og:title" content="堡垒机的核心武器：WebSSH录像实现" />
  <meta property="og:description" content="堡垒机的核心武器：WebSSH录像实现" />
  <link rel="canonical" href="https://ops-coffee.cn/" />
  <!-- End SEO tag -->

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-145167079-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-145167079-1');
  </script>

  <!--
  <script data-ad-client="ca-pub-8944257246828217" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  -->
</head>

<body>
  <header class="header">
    <div class="inner">
      <a href="https://ops-coffee.cn/">
        <h1>运维咖啡吧</h1>
      </a>
      <h2>追求技术的道路上，我从不曾停下脚步</h2>
    </div>

	  <div class="mobile">
      <a class="site" href="/">运维咖啡吧</a>
      <nav class="header-menu">
        <ul>
          <li class=""><a href="javascript:void(0);" id="showMenu">MENU</a></li>
        </ul>
      </nav>
    </div>
  </header>

  <div id="content-wrapper">
    <div class="inner clearfix">
      <section id="main-content">
        
        <h1 id="art-title">堡垒机的核心武器：WebSSH录像实现</h1>
        

        <blockquote>
<p>WebSSH终端录像的实现终于来了</p>
</blockquote>
<p>前边写了两篇文章<a href="https://ops-coffee.cn/s/oqZqGiQ3uNrNuT-nGrh9lg">『Asciinema：你的所有操作都将被录制』</a>和<a href="https://ops-coffee.cn/s/PcstaBodjDS8D15ARwAfzA">『Asciinema文章勘误及Web端使用介绍』</a>深入介绍了终端录制工具Asciinema，我们已经可以实现在终端下对操作过程的录制，那么在WebSSH中的操作该如何记录并提供后续的回放审计呢？</p>
<p>一种方式是<a href="https://ops-coffee.cn/s/oqZqGiQ3uNrNuT-nGrh9lg">『Asciinema：你的所有操作都将被录制』</a>文章最后介绍的自动录制审计日志的方法，在主机上添加个脚本，每次连接自动进行录制，但这样不仅要在每台远程主机添加脚本，会很繁琐，而且录制的脚本文件都是放在远程主机上的，后续播放也很麻烦</p>
<p>那该如何更好处理呢？下文介绍一种优雅的方式来实现，核心思想是不通过录制命令进行录制，而在Webssh交互执行的过程中直接<strong>生成可播放的录像文件</strong></p>
<h2 id="_1">设计思路</h2>
<p>通过上边两篇文章的阅读，我们已经知道了Asciinema录像文件主要由两部分组成：header头和IO流数据</p>
<p>header头位于文件的第一行，定义了这个录像的版本、宽高、开始时间、环境变量等参数，我们可以在websocket连接创建时将这些参数按照需要的格式写入到文件</p>
<p>header头数据如下，只有开头一行，是一个字典形式</p>
<pre class="codehilite"><code>{&quot;version&quot;: 2, &quot;width&quot;: 213, &quot;height&quot;: 55, &quot;timestamp&quot;: 1574155029.1815443, &quot;env&quot;: {&quot;SHELL&quot;: &quot;/bin/bash&quot;, &quot;TERM&quot;: &quot;xterm-256color&quot;}, &quot;title&quot;: &quot;ops-coffee&quot;}</code></pre>


<p>整个录像文件除了第一行的header头部分，剩下的就都是输入输出的IO流数据，从websocket连接建立开始，随着操作的进行，IO流数据是不断增加的，直到整个websocket长连接的结束，那就需要在整个WebSSH交互的过程中不断的往录像文件追加输入输出的内容</p>
<p>IO流数据如下，每一行一条，列表形式，分别表示操作时间，输入或输出（这里我们为了方便就写固定字符串输出），IO数据</p>
<pre class="codehilite"><code>[0.2341010570526123, &quot;o&quot;, &quot;Last login: Tue Nov 19 17:11:30 2019 from 192.168.105.91\r\r\n&quot;]</code></pre>


<p>似乎很完美，按照上边的思路录像文件就应该没有问题了，但还有一些细节需要处理</p>
<p>首先是需要历史连接列表，在这个列表里可以看到什么时间，哪个用户连接了哪台主机，当然也需要提供回放功能，新建一张表来记录这些信息</p>
<pre class="codehilite"><code>class Record(models.Model):
    create_time = models.DateTimeField(auto_now_add=True, verbose_name='创建时间')

    host = models.ForeignKey(Host, on_delete=models.CASCADE, verbose_name='主机')
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='用户')

    filename = models.CharField(max_length=128, verbose_name='录像文件名称')

    def __str__(self):
        return self.host</code></pre>


<p>其次还需要考虑的一个问题是header和后续IO数据流要写入同一个文件，这就需要在整个websocket的连接过程中有一个<strong>固定</strong>的文件名可被读取，这里我使用了主机+用户+当前时间作为文件名，同一用户在同一时间不能多次连接同一主机，这样可保证文件名不重复，同时避免操作写入错误的录像文件，文件名在websocket建立时初始化</p>
<pre class="codehilite"><code>def __init__(self, host, user, websocket):
    self.host = host
    self.user = user

    self.time = time.time()
    self.filename = '%s.%s.%d.cast' % (host, user, self.time)</code></pre>


<p>IO流数据会持续不断的写入文件，这里以一个独立的方法来处理写入</p>
<pre class="codehilite"><code>def record(self, type, data):
    RECORD_DIR = settings.BASE_DIR + '/static/record/'
    if not os.path.isdir(RECORD_DIR):
        os.makedirs(RECORD_DIR)

    if type == 'header':
        Record.objects.create(
            host=Host.objects.get(id=self.host),
            user=self.user,
            filename=self.filename
        )

        with open(RECORD_DIR + self.filename, 'w') as f:
            f.write(json.dumps(data) + '\n')
    else:
        iodata = [time.time() - self.time, 'o', data]
        with open(RECORD_DIR + self.filename, 'a', buffering=1) as f:
            f.write((json.dumps(iodata) + '\n'))</code></pre>


<p>record接收两个参数type和data，type标识本次写入的是header头还是IO流，data则是具体的数据</p>
<p>header只需要执行一次写入，所以将其放在ssh的connect方法中，只在ssh连接建立时执行一次，在执行header写入时同时往数据库插入新的历史记录数据</p>
<p>调用record方法写入header</p>
<pre class="codehilite"><code>def connect(self, host, port, username, authtype, password=None, pkey=None,
            term='xterm-256color', cols=80, rows=24):
    ...

    # 构建录像文件header
    self.record('header', {
        &quot;version&quot;: 2,
        &quot;width&quot;: cols,
        &quot;height&quot;: rows,
        &quot;timestamp&quot;: self.time,
        &quot;env&quot;: {
            &quot;SHELL&quot;: &quot;/bin/bash&quot;,
            &quot;TERM&quot;: term
        },
        &quot;title&quot;: &quot;ops-coffee&quot;
    })</code></pre>


<p>IO流数据则需要与返回给前端的数据保持一致，这样就能保证前端显示什么录像就播放什么了，所以所有需要返回前端数据的地方都同时写入录像文件即可</p>
<p>调用record方法写入io流数据</p>
<pre class="codehilite"><code>def connect(self, host, port, username, authtype, password=None, pkey=None,
            term='xterm-256color', cols=80, rows=24):
    ...

    # 连接建立一次，之后交互数据不会再进入该方法
    for i in range(2):
        recv = self.ssh_channel.recv(65535).decode('utf-8', 'ignore')
        message = json.dumps({'flag': 'success', 'message': recv})
        self.websocket.send(message)

        self.record('iodata', recv)

...

def _ssh_to_ws(self):
    try:
        with self.lock:
            while not self.ssh_channel.exit_status_ready():
                data = self.ssh_channel.recv(1024).decode('utf-8', 'ignore')
                if len(data) != 0:
                    message = {'flag': 'success', 'message': data}
                    self.websocket.send(json.dumps(message))

                    self.record('iodata', data)
                else:
                    break
    except Exception as e:
        message = {'flag': 'error', 'message': str(e)}
        self.websocket.send(json.dumps(message))
        self.record('iodata', str(e))

        self.close()</code></pre>


<p>由于命令执行与返回都是多线程的操作，这就会导致在写入文件时出现文件乱序影响播放的问题，典型的操作有vim、top等，通过加锁<code>self.lock</code>可以顺利解决</p>
<p>最后历史记录页面，当用户点击播放按钮时，调用js弹出播放窗口</p>
<pre class="codehilite"><code>&lt;div class=&quot;modal fade&quot; id=&quot;modalForm&quot;&gt;
  &lt;div class=&quot;modal-dialog modal-lg&quot;&gt;
    &lt;div class=&quot;modal-content&quot;&gt;
      &lt;div class=&quot;modal-body&quot; id=&quot;play&quot;&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;

// 播放录像
function play(host,user,time,file) {
  $('#play').html(
    '&lt;asciinema-player id=&quot;play&quot; title=&quot;WebSSH Record&quot; author=&quot;ops-coffee.cn&quot; author-url=&quot;https://ops-coffee.cn&quot; author-img-url=&quot;/static/img/logo.png&quot; src=&quot;/static/record/'+file+'&quot; speed=&quot;3&quot; '+
    'idle-time-limit=&quot;2&quot; poster=&quot;data:text/plain,\x1b[1;32m'+time+
    '\x1b[1;0m用户\x1b[1;32m'+user+
    '\x1b[1;0m连接主机\x1b[1;32m'+host+
    '\x1b[1;0m的录像记录&quot;&gt;&lt;/asciinema-player&gt;'
  )

  $('#modalForm').modal('show');
}</code></pre>


<p>asciinema-player标签的详细参数介绍可以看这篇文章<a href="https://ops-coffee.cn/s/PcstaBodjDS8D15ARwAfzA">『Asciinema文章勘误及Web端使用介绍』</a></p>
<h2 id="_2">演示与总结</h2>
<p><img alt="" src="https://blz.nosdn.127.net/sre/images/20191119.gif" /></p>
<p>在写入文件的方案中，考虑了实时写入和一次性写入，实时写入就像上边这样，所有的操作都会实时写入录像文件，好处是录像不丢失，且能在操作的过程中进行实时的播放，缺点也很明显，就是会频繁的写文件，造成IO开销</p>
<p>一次性写入可以在用户操作的过程中将录像数据写入内存，在websocket关闭时一次性异步写入到文件中，这种方案在最终写入文件时可能因为种种原因而失败，从而导致录像丢失，还有个缺点是当你WebSSH操作时间过长时，会导致内存的持续增加</p>
<p>两种方案一种是对磁盘的消耗另一种是对内存的消耗，各有利弊，当然你也可以考虑批量写入，例如每分钟写一次文件，一分钟之内的保存在内存中，平衡内存和磁盘的消耗，期待你的实现</p>
<hr />
<p><img alt="扫码关注公众号查看更多实用文章" src="https://blz.nosdn.127.net/sre/wx.qrcode.png" /></p>
<p>相关文章推荐阅读：</p>
<ul>
<li><a href="https://ops-coffee.cn/s/FHDyvHsh-oO1cn7AXk_4WA">Django实现WebSSH操作Kubernetes Pod</a></li>
<li><a href="https://ops-coffee.cn/s/a3eJjVTtuUjzwyk21nTBqQ">Django实现WebSSH操作物理机或虚拟机</a></li>
</ul>

        <div id="only-mobile" style="width:100%">
          <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
          <ins class="adsbygoogle"
               style="display:block"
               data-ad-client="ca-pub-8944257246828217"
               data-ad-slot="6731434232"
               data-ad-format="auto"
               data-full-width-responsive="true"></ins>
          <script>
               (adsbygoogle = window.adsbygoogle || []).push({});
          </script>
        </div>
      </section>

      <aside id="sidebar">
        <button onclick="javascrtpt:window.open('/search.html')" style="width:100%;cursor:pointer">站内搜索</button>

<blockquote class="route">作者介绍</blockquote>
<p>37丫37，Cloud操作员，Code搬运工，涉猎广泛，重原则，有态度</p>
<p>运营公众号【运维咖啡吧】，这是一个不落俗套坚持初心的公众号，一个你不可错过的公众号</p>
<img border="0" src="https://blz.nosdn.127.net/sre/images/z-qrcode.jpg" width="100%" height="100%" alt="ops-coffee">
<p>欢迎关注，后台回复“小二”加我微信，聊技术，谈理想，悟人生</p>

<blockquote class="route">归档列表</blockquote>
<div class="sidebar-list"><a href="/s" target="_blank"> 精选文章列表</a></div>
<div class="sidebar-list"><a href="/t/" target="_blank"> 日常运维记录</a></div>
<div class="sidebar-list"><a href="/devops" target="_blank"> 运维系统平台</a></div>
<div class="sidebar-list"><a href="/webssh" target="_blank"> WebSSH系列</a></div>

<blockquote class="route">锟斤拷锟斤</blockquote>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- sidebar -->
<ins class="adsbygoogle"
     style="display:block"
     data-ad-client="ca-pub-8944257246828217"
     data-ad-slot="1313935804"
     data-ad-format="auto"
     data-full-width-responsive="true"></ins>
<script>
     (adsbygoogle = window.adsbygoogle || []).push({});
</script>
      </aside>

    </div>
  </div>

  <footer class="footer">
    <div class="inner">
      <div class="copy"> © 2019 ops-coffee</div>

      <div class="link">
        <a href="#sidebar" onclick="if(confirm('扫描二维码，关注我吧')==false)return false;" title="关于本站" target="">关于本站</a>
        <a href="/friends" title="友情链接" target="_blank">友情链接</a>
      </div>
    </div>
  </footer>
</body>

<script>
  document.getElementById("showMenu").onclick=function(){
      if (document.getElementById("showMenu").innerText == 'MENU') {
      document.getElementById("showMenu").innerText = 'BACK';
      document.getElementById('sidebar').style.display="block";
      document.getElementById('main-content').style.display="none";
    } else {
      document.getElementById("showMenu").innerText = 'MENU';
      document.getElementById('sidebar').style.display="none";
      document.getElementById('main-content').style.display="block";
    }
  }
</script>
</html>